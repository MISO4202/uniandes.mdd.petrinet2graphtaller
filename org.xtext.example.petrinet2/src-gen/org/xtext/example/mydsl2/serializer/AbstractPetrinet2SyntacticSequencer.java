/*
 * generated by Xtext
 */
package org.xtext.example.mydsl2.serializer;

import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;
import org.xtext.example.mydsl2.services.Petrinet2GrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractPetrinet2SyntacticSequencer extends AbstractSyntacticSequencer {

	protected Petrinet2GrammarAccess grammarAccess;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (Petrinet2GrammarAccess) access;
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (ruleCall.getRule() == grammarAccess.getEQUALSRule())
			return getEQUALSToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getGREATERRule())
			return getGREATERToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getIDRule())
			return getIDToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getLESSRule())
			return getLESSToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getQUESTIONRule())
			return getQUESTIONToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getSLASHRule())
			return getSLASHToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTINPUTARCRule())
			return getTINPUTARCToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTOUTPUTARCRule())
			return getTOUTPUTARCToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTPLACERule())
			return getTPLACEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTTRANSITIONRule())
			return getTTRANSITIONToken(semanticObject, ruleCall, node);
		return "";
	}
	
	/**
	 * terminal EQUALS:
	 * "=";
	 */
	protected String getEQUALSToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "=";
	}
	
	/**
	 * terminal GREATER:
	 * ">";
	 */
	protected String getGREATERToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ">";
	}
	
	/**
	 * terminal ID:
	 * "id";
	 */
	protected String getIDToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "id";
	}
	
	/**
	 * terminal LESS:
	 * "<";
	 */
	protected String getLESSToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "<";
	}
	
	/**
	 * terminal QUESTION:
	 * "?";
	 */
	protected String getQUESTIONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "?";
	}
	
	/**
	 * terminal SLASH:
	 * "/";
	 */
	protected String getSLASHToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "/";
	}
	
	/**
	 * terminal TINPUTARC:
	 * "inputarc";
	 */
	protected String getTINPUTARCToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "inputarc";
	}
	
	/**
	 * terminal TOUTPUTARC:
	 * "outputarc";
	 */
	protected String getTOUTPUTARCToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "outputarc";
	}
	
	/**
	 * terminal TPLACE:
	 * "place";
	 */
	protected String getTPLACEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "place";
	}
	
	/**
	 * terminal TTRANSITION:
	 * "transition";
	 */
	protected String getTTRANSITIONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "transition";
	}
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

}
